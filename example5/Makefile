# -----------------------------------------------------------
# Compiler and flags
# -----------------------------------------------------------
# CC: C compiler (override at CLI: `make CC=clang`)
CC        := gcc

# CFLAGS: Compiler flags
# -Wall -Wextra : enable useful warnings
# -O2           : reasonable optimization for release builds
# -MMD -MP      : auto-generate header dependency files (.d) per .c
CFLAGS    ?= -Wall -Wextra -O2 -MMD -MP

# CPPFLAGS: Preprocessor flags (e.g., include search paths)
# -Iinclude   : look for headers in the 'include/' directory
CPPFLAGS  := -Iinclude

# Linker flags and libraries (override as needed)
LDFLAGS   :=
LDLIBS    :=

# -----------------------------------------------------------
# Project directories
# -----------------------------------------------------------
SRC_DIR   := src
INC_DIR   := include
BUILD_DIR := build

# Final program name
TARGET    := myapp

# -----------------------------------------------------------
# Source → Object mapping
# -----------------------------------------------------------
# Collect all C sources from src/
SRC       := $(wildcard $(SRC_DIR)/*.c)

# Map 'src/foo.c' → 'build/foo.o'
OBJ       := $(patsubst $(SRC_DIR)/%.c,$(BUILD_DIR)/%.o,$(SRC))

# The corresponding auto-generated dependency files (*.d)
DEPS      := $(OBJ:.o=.d)

# -----------------------------------------------------------
# Phony targets
# -----------------------------------------------------------
.PHONY: all clean debug release run print-vars

# Default target: build release
all: release

# -----------------------------------------------------------
# Build modes (modify CFLAGS via +=)
# -----------------------------------------------------------
# Release build: define NDEBUG, keep O2
release: CFLAGS += -DNDEBUG
release: $(TARGET)

# Debug build: add symbols, disable optimization, define DEBUG
debug:   CFLAGS += -g -O0 -DDEBUG
debug:   $(TARGET)

# -----------------------------------------------------------
# Link step: produce the final executable
# -----------------------------------------------------------
# $(TARGET) depends on all object files
# $@ → target (myapp), $^ → all prerequisites (object files)
$(TARGET): $(OBJ)
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

# -----------------------------------------------------------
# Pattern rule: compile src/foo.c → build/foo.o
# -----------------------------------------------------------
# Order-only prerequisite (`| $(BUILD_DIR)`) ensures build/ exists
# $< → first prerequisite (the .c file)
$(BUILD_DIR)/%.o: $(SRC_DIR)/%.c | $(BUILD_DIR)
	$(CC) $(CPPFLAGS) $(CFLAGS) -c $< -o $@

# Ensure build directory exists before compiling15 Dec to 21 Dec
$(BUILD_DIR):
	@mkdir -p $(BUILD_DIR)

# -----------------------------------------------------------
# Auto header dependencies
# -----------------------------------------------------------
# Include *.d files generated by -MMD -MP so header changes trigger rebuilds.
# The leading '-' ignores missing .d files on the very first build.
-include $(DEPS)

# -----------------------------------------------------------
# Utility targets
# -----------------------------------------------------------
clean:
	rm -rf $(BUILD_DIR) $(TARGET)

# Convenience: run the built program
run: $(TARGET)
	./$(TARGET)

# Debugging/teaching: show variable values
print-vars:
	@echo "CC        = $(CC)"
	@echo "CFLAGS    = $(CFLAGS)"
	@echo "CPPFLAGS  = $(CPPFLAGS)"
	@echo "LDFLAGS   = $(LDFLAGS)"
	@echo "LDLIBS    = $(LDLIBS)"
	@echo "SRC_DIR   = $(SRC_DIR)"
	@echo "INC_DIR   = $(INC_DIR)"
	@echo "BUILD_DIR = $(BUILD_DIR)"
	@echo "SRC       = $(SRC)"
	@echo "OBJ       = $(OBJ)"